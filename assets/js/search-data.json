{
  
    
        "post0": {
            "title": "Merklist",
            "content": "Definition . This definition of a hash of a list of elements is pretty simple: . A list element is an arbitrary buffer of bytes. Any length, any content. Just bytes. | A list, then, is a sequence of such elements. | The hash of a list element is the cryptographic hash of its bytes, formatted into a square matrix with byte elements. (More details later.) | The hash of a list is reduction by matrix multiplication of the hashes of all the list elements in the same order as they appear in the list. | The hash of a list with 0 elements is the identity matrix. | . This construction has a couple notable concequences: . The hash of a list with only one item is just the hash of the item itself. | You can calculate the hash of any list concatenated with itself by matrix multiplication of the the hash with itself. This works for single elements as well as arbitrarily long lists. | A list can have multiple copies of the same list item, and swapping them does not affect the list hash. Consider how swapping the first two elements in [1, 1, 2] doesn&#39;t change it. | Concatenating two lists is accomplished by matrix multiplication of their hashes, in the correct order. | Appending or prepending lists of 0 elements yields the same hash, as expected. | . Lets explore this definition in more detail with a simple implementation in python+numpy. . import hashlib import numpy as np from functools import reduce def assert_equal(a, b): return np.testing.assert_equal(a, b) def assert_not_equal(a, b): return np.testing.assert_raises(AssertionError, np.testing.assert_equal, a, b) . The hash of a list element - hash_m/1 . The function hash_m/1 takes a buffer of bytes as its first argument, and returns the sha512 hash of the bytes formatted as an 8×8 2-d array of 8-bit unsigned integers with wrapping overflow. This is the hash of a list element consisting of those bytes. Based on a shallow wikipedia dive, someone familiar with linear algebra might say it&#39;s a matrix ring, $R_{256}^{8×8}$. Not coincidentally, sha512 outputs 512 bits = 64 bytes = 8 * 8 array of bytes, how convenient. (In fact, that might even be the primary reason why I chose sha512!) . def hash_m(e): hash_bytes = list(hashlib.sha512(e).digest())[:64] # hash the bytes e, convert the digest into a list of 64 bytes return np.array(hash_bytes, dtype=np.uint8).reshape((8,8)) # convert the digest bytes into a numpy array with the appropriate data type and shape . 8×8 seems big compared to 3×3 or 4×4 matrixes. The values are as random as you might expect a cryptographic hash to be, and range from 0-255: . print(hash_m(b&quot;Hello A&quot;)) print() print(hash_m(b&quot;Hello B&quot;)) . [[ 14 184 108 217 131 164 222 93] [132 227 82 144 111 178 195 109] [ 25 250 155 17 131 183 151 217] [212 60 138 36 0 60 115 181] [ 51 0 87 43 93 252 56 61] [108 239 175 222 23 142 41 216] [203 98 234 13 65 169 255 240] [ 46 127 15 167 112 153 222 94]] [[ 63 144 188 5 57 146 32 56] [ 27 189 98 140 113 194 70 87] [115 21 136 27 116 167 85 48] [ 29 162 119 29 104 32 145 241] [166 197 57 165 132 213 50 202] [ 48 71 33 19 230 26 58 164] [242 172 65 202 193 50 193 141] [206 110 165 129 52 132 250 73]] . The hash of a list - mul_m/2 . Ok so we&#39;ve got our element hashes, how do we combine them to construct the hash of a list? We defined the hash of the list to be reduction by matrix multiplication of the hash of each element: . def mul_m(he1, he2): return np.matmul(he1, he2, dtype=np.uint8) # just, like, multiply them . Consider an example: . elements = [b&quot;A&quot;, b&quot;Hello&quot;, b&quot;World&quot;] # first hash each element element_hashes = [hash_m(e) for e in elements] # get the hash of the list by reducing the hashes by matrix multiplication list_hash1 = mul_m(mul_m(element_hashes[0], element_hashes[1]), element_hashes[2]) # an alternative way to write the reduction list_hash2 = reduce(mul_m, element_hashes) . print(&quot;List of elements:&quot;) print(elements) print(&quot; nHash of each element:&quot;) print(element_hashes) print(&quot; nHash of full list:&quot;) print(list_hash1) assert_equal(list_hash1, list_hash2) . List of elements: [b&#39;A&#39;, b&#39;Hello&#39;, b&#39;World&#39;] Hash of each element: [array([[ 33, 180, 244, 189, 158, 100, 237, 53], [ 92, 62, 182, 118, 162, 142, 190, 218], [246, 216, 241, 123, 220, 54, 89, 149], [179, 25, 9, 113, 83, 4, 64, 128], [ 81, 107, 208, 131, 191, 204, 230, 97], [ 33, 163, 7, 38, 70, 153, 76, 132], [ 48, 204, 56, 43, 141, 197, 67, 232], [ 72, 128, 24, 59, 248, 86, 207, 245]], dtype=uint8), array([[ 54, 21, 248, 12, 157, 41, 62, 215], [ 64, 38, 135, 249, 75, 34, 213, 142], [ 82, 155, 140, 199, 145, 111, 143, 172], [127, 221, 247, 251, 213, 175, 76, 247], [119, 211, 215, 149, 167, 160, 10, 22], [191, 126, 127, 63, 185, 86, 30, 233], [186, 174, 72, 13, 169, 254, 122, 24], [118, 158, 113, 136, 107, 3, 243, 21]], dtype=uint8), array([[142, 167, 115, 147, 164, 42, 184, 250], [146, 80, 15, 176, 119, 169, 80, 156], [195, 43, 201, 94, 114, 113, 46, 250], [ 17, 110, 218, 242, 237, 250, 227, 79], [187, 104, 46, 253, 214, 197, 221, 19], [193, 23, 224, 139, 212, 170, 239, 113], [ 41, 29, 138, 172, 226, 248, 144, 39], [ 48, 129, 208, 103, 124, 22, 223, 15]], dtype=uint8)] Hash of full list: [[178 188 57 157 60 136 190 127] [ 40 234 254 224 38 46 250 52] [156 72 193 136 219 98 28 4] [197 2 43 132 132 232 254 198] [ 93 64 113 215 2 246 130 192] [ 91 107 85 13 149 60 19 173] [ 84 77 244 98 0 239 123 17] [ 58 112 98 250 163 20 27 6]] . What does this give us? Generally speaking, multiplying two square matrixes $M_1×M_2$ gives us at least these two properties: . Associativity - Associativity enables you to reduce a computation using any partitioning because all partitionings yield the same result. Addition is associative $(1+2)+3 = 1+(2+3)$, subtraction is not $(5-3)-2 neq5-(3-2)$. (Associative property) | Non-Commutativity - Commutativity allows you to swap elements without affecting the result. Addition is commutative $1+2 = 2+1$, but division is not $1 div2 neq2 div1$. And neither is matrix multiplication. (Commutative property) | . This is an unusual combination of properties for an operation, at least not a combination encountered under normal algebra operations: . associative commutative . + | ✅ | ✅ | . * | ✅ | ✅ | . - | ❌ | ❌ | . / | ❌ | ❌ | . exp | ❌ | ❌ | . M×M | ✅ | ❌ | . Upon consideration, these are the exact properties that one would want in order to define the hash of a list of items. Non-commutativity enables the order of elements in the list to be well-defined, since swapping different elements produces a different hash. Associativity enables caching the summary of an arbitrary sublist; I expect that doing this heirarchally on a huge list enables an algorithm to calculate the hash of any sublist at the cost of O(log(N)) time and space. . Lets sanity-check that these properties can hold for the construction described above. . Associativity . f1 = hash_m(b&quot;Hello A&quot;) f2 = hash_m(b&quot;Hello B&quot;) f3 = hash_m(b&quot;Hello C&quot;) . x = np.matmul(np.matmul(f1, f2), f3) # y is calculated by association (f1 × (f2 × f3)) y = np.matmul(f1, np.matmul(f2, f3)) # observe that they produce the same result assert_equal(x, y) . print(x) print() print(y) . [[ 58 12 144 134 100 158 159 51] [ 73 206 202 190 87 79 223 2] [210 122 142 117 37 148 106 45] [175 146 187 223 235 171 64 226] [149 85 203 87 92 251 243 206] [ 18 252 160 103 125 251 181 133] [191 132 220 104 213 154 34 154] [127 197 95 87 166 3 22 3]] [[ 58 12 144 134 100 158 159 51] [ 73 206 202 190 87 79 223 2] [210 122 142 117 37 148 106 45] [175 146 187 223 235 171 64 226] [149 85 203 87 92 251 243 206] [ 18 252 160 103 125 251 181 133] [191 132 220 104 213 154 34 154] [127 197 95 87 166 3 22 3]] . Non-Commutativity . x = np.matmul(f1, f2) # y is f2 × f1 y = np.matmul(f2, f1) # observe that they produce different results assert_not_equal(x, y) . print(x) print() print(y) . [[ 87 79 149 131 148 247 195 90] [249 84 195 58 142 133 211 15] [177 93 69 254 240 234 97 37] [ 46 84 76 253 55 200 43 236] [ 21 84 99 157 55 148 170 2] [168 123 6 250 64 144 54 242] [230 78 164 76 30 29 214 68] [ 47 183 156 239 157 177 192 184]] [[149 18 239 238 84 188 191 109] [239 150 214 235 59 161 9 133] [ 89 174 59 14 70 113 124 243] [ 66 113 176 124 227 247 17 25] [247 138 152 181 177 143 184 97] [113 249 199 153 154 75 45 105] [121 201 225 42 249 213 180 244] [ 85 31 72 28 181 182 140 176]] . Other functions . list1 = [hash_m(b&quot;A&quot;) for _ in range(0, 1024)] hash1 = reduce(mul_m, list1) # Take a starting element and square/double it 10 times. With 1 starting element over 10 doublings = 1024 elements hash2 = reduce((lambda m, _ : mul_m(m, m)), range(0, 10), hash_m(b&quot;A&quot;)) # Observe that these two methods of calculating the hash have the same result assert_equal(hash1, hash2) # lets call it double def double_m(m, d=1): return reduce((lambda m, _ : mul_m(m, m)), range(0, d), m) assert_equal(hash1, double_m(hash_m(b&quot;A&quot;), 10)) def identity_m(): return np.identity(8, dtype=np.uint8) # generalize to any length, not just doublings, performed in ln(N) matmuls def repeat_m(m, n): res = identity_m() while n &gt; 0: # concatenate the current doubling iff the bit representing this doubling is set if n &amp; 1: res = mul_m(res, m) n &gt;&gt;= 1 m = mul_m(m, m) # double matrix m # print(s) return res # repeat_m can do the same as double_m assert_equal(hash1, repeat_m(hash_m(b&quot;A&quot;), 1024)) # but it can also repeat any number of times hash3 = reduce(mul_m, (hash_m(b&quot;A&quot;) for _ in range(0, 3309))) assert_equal(hash3, repeat_m(hash_m(b&quot;A&quot;), 3309)) # Even returns a sensible result when requesting 0 elements assert_equal(identity_m(), repeat_m(hash_m(b&quot;A&quot;), 0)) # make helper for reducing an iterable of hashes def reduce_m(am): return reduce(mul_m, am) . print(hash1) print() print(hash2) print() print(np.identity(8,&quot;B&quot;)) . [[ 68 252 159 3 14 52 199 199] [136 124 6 34 58 174 206 54] [ 3 234 2 13 120 240 7 163] [102 47 66 61 87 234 246 72] [ 19 135 80 115 75 242 242 5] [244 165 250 28 76 43 188 254] [233 46 187 39 151 241 175 130] [132 138 6 215 20 132 89 33]] [[ 68 252 159 3 14 52 199 199] [136 124 6 34 58 174 206 54] [ 3 234 2 13 120 240 7 163] [102 47 66 61 87 234 246 72] [ 19 135 80 115 75 242 242 5] [244 165 250 28 76 43 188 254] [233 46 187 39 151 241 175 130] [132 138 6 215 20 132 89 33]] [[1 0 0 0 0 0 0 0] [0 1 0 0 0 0 0 0] [0 0 1 0 0 0 0 0] [0 0 0 1 0 0 0 0] [0 0 0 0 1 0 0 0] [0 0 0 0 0 1 0 0] [0 0 0 0 0 0 1 0] [0 0 0 0 0 0 0 1]] . Fun with associativity . Does the hash of a list change even when swapping two elements in the middle of a very long list? . a = hash_m(b&quot;A&quot;) b = hash_m(b&quot;B&quot;) a499 = repeat_m(a, 499) a500 = repeat_m(a, 500) # this should work because they&#39;re all a&#39;s assert_equal(reduce_m([a, a499]), a500) assert_equal(reduce_m([a499, a]), a500) # these are lists of 999 elements of a, with one b at position 500 (x) or 501 (y) x = reduce_m([a499, b, a500]) y = reduce_m([a500, b, a499]) # shifting the b by one element changed the hash assert_not_equal(x, y) . Flex that associativity (a × (a499 × b × a500) × (a500 × b × a499) × a) = (a500 × b × (a500 × a500) × b × a500) . assert_equal(reduce_m([a, x, y, a]), reduce_m([a500, b, repeat_m(a500, 2), b, a500])) . Unknowns . This appears to me to be a reasonable way to define the hash of a list. The mathematical definition of a list aligns very nicely with the properties offered by matrix multiplication. But is it appropriate to use for the same things that a Merkle Tree would be? The big questions are related to the valuable properties of hash functions: . Given a merklist summary or sublist summaries of it, can you derive the hashes of elements or their order? (Elements themselves are protected by the preimage resistance of the underlying hash function.) If yes, when is that a problem? | . | Given a merklist summary but not the elements, is it possible to produce a different list of elements that hash to the same summary? (~preimage resistance) | Is it possible to predictably alter the merklist summary by concatenating it with some other sublist of real elements? | Are there other desirable security properties that would be valuable for a list hash? | Is there a better choice of hash function as a primitive than sha512? | Is there a better choice of reduction function that still retains associativity+non-commutativity than simple matmul? | Is there a more appropriate size than an 8x8 matrix / 64 bytes to represent merklist summaries? | . Matrixes are well-studied objects, perhaps such information is already known. If you know something about deriving the preimage of the multiplication of a matrix ring, $R_{256}^{8×8}$, I would be very interested to know. . What&#39;s next? . *If this construction has the appropriate security properties*, it seems to be a better merkle tree in all respects. Any use of a merkle tree could be replaced with this, and it could enable use-cases where merkle trees aren&#39;t useful. Some examples of what I think might be possible: . Using a Merklist with a sublist summary tree structure enables creating a $O(1)$-sized &#39;Merklist Proof&#39; that can verify the addition and subtraction of any number of elements at any single point in the list using only $O(log(N))$ time and $O(log(N))$ static space. As a bonus the proof generator and verifier can have totally different tree structures and can still communicate the proof successfully. | Using a Merklist summary tree you can create a consistent hash of any ordered key-value store (like a btree) that can be maintained incrementally inline with regular node updates, e.g. as part of a LSM-tree. This could facilitate verification and sync between database replicas. | The sublist summary tree structure can be as dense or sparse as desired. You could summarize down to pairs of elements akin to a merkle tree, but you could also summarize a compressed sublist of hundreds or even millions of elements with a single hash. Of course, calculating or verifying a proof of changes to the middle of that sublist would require rehashing the whole sublist, but this turns it from a fixed structure into a tuneable parameter. | If all possible elements had an easily calculatable inverse, that would enable &quot;subtracting&quot; an element by inserting its inverse in front of it. That would basically extend the group from a ring into a field, and might have interesting implications. For example you could define a cryptographically-secure rolling hash where advancing either end can be calculated in O(1) time. | . | . To be continued... .",
            "url": "https://blog.infogulch.com/2021/07/07/Merklist.html",
            "relUrl": "/2021/07/07/Merklist.html",
            "date": " • Jul 7, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://blog.infogulch.com/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://blog.infogulch.com/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://blog.infogulch.com/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}